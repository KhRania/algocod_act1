#!/usr/bin/env python  
import roslib
roslib.load_manifest("rosparam")
import rosparam
import random
import rospy  
import yaml
from geometry_msgs.msg  import Twist  
from turtlesim.msg import Pose  
from math import pow,atan2,sqrt  
goal_x = 2
print goal_x
goal_y= 2
print goal_y
#data = rosparam.load_file("/home/tayssir/catkin_ws/src/patrol_turtle/config/param.yaml")
#print data
#param_name = rospy.search_param()
#v = rospy.get_param(param_name)
#print param_name
#print v
#rospy.loginfo("Found default parameter file")

class turtlesim():  

    def __init__(self):  
        #Creating our node,publisher and subscriber  
        rospy.init_node('turtlebot_controller', anonymous=True)  
        self.velocity_publisher = rospy.Publisher('/turtle1/cmd_vel', Twist, queue_size=10)  
        self.pose_subscriber = rospy.Subscriber('/turtle1/pose', Pose, self.callback)  
        self.pose = Pose()  
        self.rate = rospy.Rate(10)  
  
    #Callback function implementing the pose value received  
    def callback(self, data):  
        self.pose = data  
        self.pose.x = round(self.pose.x, 4)  
        self.pose.y = round(self.pose.y, 4)  
  
    def get_distance(self, goal_x, goal_y):  
        distance = sqrt(pow((goal_x - self.pose.x), 2) + pow((goal_y - self.pose.y), 2))  
        return distance  
  
    def move2goal(self):  
        goal_pose = Pose()
	distance_tolerance = 0.2
        vel_msg = Twist() 
	v = len(goal_x) - 1
	for i in range(len(goal_x)):
	 print "Goal point #"+ str(i+1) + "  : x = " + str(goal_x[i]) + " y = " + str(goal_y[i])
         goal_pose.x = goal_x[i]
	 #for j in range(len(goal_y)):
	 #print goal_y[j]
         goal_pose.y = goal_y[i]
	 if (i == v) :
	 	print "Finish Patrol_Turtle"
	  #break
	 print "================="
	 #print goal_pose.x
	 #print goal_pose.y
         while sqrt(pow((goal_pose.x - self.pose.x), 2) + pow((goal_pose.y - self.pose.y), 2)) >= distance_tolerance:  
		    #Porportional Controller  
		    #linear velocity in the x-axis:  
		    vel_msg.linear.x = 1.5 * sqrt(pow((goal_pose.x - self.pose.x), 2) + pow((goal_pose.y - self.pose.y), 2))  
		    vel_msg.linear.y = 0  
		    vel_msg.linear.z = 0  
  
		    #angular velocity in the z-axis:  
		    vel_msg.angular.x = 0  
		    vel_msg.angular.y = 0  
		    vel_msg.angular.z = 4 * (atan2(goal_pose.y - self.pose.y, goal_pose.x - self.pose.x) - self.pose.theta)  
	  
		    #Publishing our vel_msg  
		    self.velocity_publisher.publish(vel_msg)  
		    self.rate.sleep() 
	 #Stopping our robot after the movement is over  
	vel_msg.linear.x = 0  
	vel_msg.angular.z =0  
	self.velocity_publisher.publish(vel_msg)  
	rospy.spin()  
	  
if __name__ == '__main__':  
    try:  
        #Testing our function  
        x = turtlesim()  
        x.move2goal()  
  
    except rospy.ROSInterruptException: 
	pass
